### Symfony2 Unit Testing Proposal 

## Outline
* PHPUnit provides for the core of Symfony2's testing capabilities 
* Unit and functional tests will be collect in each bundle's Testing directory 
	for eash organization and batch execution
* TSSAA's testing requirements are somewhat simplified by the fact that the ui
	and backend are separate components
* Given the pacing of this project, initial testing efforts will be directed 
	toward testing the content of the json responses generated by the backend
* UI tesing modules will be developed in conjuction with further maturation of the 
	UI

## Proposal
Symfony2 provides facilities for coding, organizing, and executing functional and unit tests.
TSSAA will feature tests organized in each of the respective bundles' subdirectories, following this
patern:
	
	{app_root}/src/Ksoft/Tssaa/{bundle_name}/Testing/{Controller|Entity}/{test_classes}
	
As implied by the above pattern, tests will be organized according to what aspect of the MVC pattern they test.

As PHPUnit provides Symfony2 with it's testing capabality, extensive use of this library will feature
prominently in our workflow. __PHPUnit version 3.5.11 or later is required for testing Symfony2 applications.__ 

PHPUnit's Symfony2 relevant options can be configured in {app_root}/app/phpunit.xml.dist.

At this juncture, PHPUnit and Symfony2 integration is accomplished at PHPUnit's runtime via the following
command pattern:

	# from {app_root}
	$ phpunit -c app/ src/Ksoft/Tssaa/{bundle_name}/Tests/{Controller|Entity}/{test_class}
	
The `-c` flag takes a path that should contain a PHPUnit config file. Following is the path specifying 
which test or collection of tests to run. PHPUnit will run all tests in the specified path down to an individual
test.  

Initially, our efforts will focus functional tests ensuring that the backend is properly processing requests via examination 
of the response JSON. Consider this example:

		<?php
		namespace Ksoft\Tssaa\LoginBundle\Tests\Controller;

		// use statement imports the WebTestCase class from Symfony2's framework bundle 
		use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

		// convention provides for tight integration: test classes are named for 
		// the class they test suffixed with 'Test'	
		class LoginControllerTest extends WebTestCase {
			
			// each function is named for the action it tests, prefixed by 'test' 
			public function testLogin() {

				// here is one of our workhorses:  a client  object is created and used
				// to access and manipulate the application
				$client = static::createClient();

				$credentials = array('login' => 'bob', 'pass' => 'password');

				$client->request('POST', '/login', $credentials);
				$this->assertTrue($client->getResponse()->isSuccessful());
			}
		}
	

Symfony2 also provides powerful methods for testing the UI. Any call to `$client->request()` returns 
a response wrapped in a crawler object that can be used to traverse the response's DOM and interact with 
it.  
	
	$crawler = $client->request('GET', 'login');
	$form = $crawler->selectButton('submit')->form();
	
	$form['login'] = "Bob";
	$form['pass'] = "testp4ss";	
	
	$crawler = $client->submit($form);
	
## Recommendations
My assessment and consumate recommendation is that we should pursue a deliberate shift in work and design 
methodology toward unit and functional testing. For any given module, I've found the following workflow to 
be effective: 
	#### By order of implementation
	1. Entity
	2. Controller
	3. Test
	4. UI  

However, I feel that using test writing as the basis of modeling controller logic is quite powerful and 
will seek to utilize that pattern in the future. 
